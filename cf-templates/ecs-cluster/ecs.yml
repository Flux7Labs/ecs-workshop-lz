---
AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for deploying ECS cluster'
# TODO:
# 1. Create ECS cluster
# 2. Create ALB
# 3. Launch seed service

Parameters:
  KeyName:
    Type: String
    Description: Optional - Name of an existing EC2 KeyPair to enable SSH access to
      the ECS instances
    Default: ''
  EcsInstanceType:
    Type: String
    Description: ECS EC2 instance type
    Default: t2.micro
    ConstraintDescription: must be a valid EC2 instance type.
  AsgMaxSize:
    Type: Number
    Description: Maximum size and initial Desired Capacity of ECS Auto Scaling Group
    Default: '2'
  AsgMinSize:
    Type: Number
    Description: Minimum size of ECS Auto Scaling Group
    Default: '2'
  IamRoleInstanceProfile:
    Type: String
    Description: Name or the Amazon Resource Name (ARN) of the instance profile associated
      with the IAM role for the instance
  EcsPort:
    Type: String
    Description: Optional - Security Group port to open on ECS instances - defaults
      to port 80
    Default: '80'
  ElbPort:
    Type: String
    Description: Optional - Security Group port to open on ELB - port 80 will be open
      by default
    Default: '80'
  ElbHealthCheckTarget:
    Type: String
    Description: Optional - Health Check Target for ELB - defaults to HTTP:80/
    Default: HTTP:80/
  SourceCidr:
    Type: String
    Description: Optional - CIDR/IP range for EcsPort and ElbPort - defaults to 0.0.0.0/0
    Default: 0.0.0.0/0
  EcsEndpoint:
    Type: String
    Description: 'Optional : ECS Endpoint for the ECS Agent to connect to'
    Default: ''
  StackPrefix:
    Type: String
    Description: String to append before exported outputs
    Default: 'ecs-workshop'
    MaxLength: 16
    AllowedPattern: '[a-z0-9\-]+'
Conditions:
  CreateEC2LCWithKeyPair:
    Fn::Not:
    - Fn::Equals:
      - Ref: KeyName
      - ''

Resources:
  LambdaExecRole:
    Type: 'AWS::IAM::Role'
    Properties:
      Path: /Common/Lambda/
      Policies:
        - PolicyName: Logging
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'logs:CreateLogGroup*'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
                Effect: Allow
        - PolicyName: Ec2DescribeImages
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'ec2:Describe*'
                Resource: '*'
                Effect: Allow
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
  GetLatestAMILambda:
    Type: 'AWS::Lambda::Function'
    Properties:
      Description: Custom resource to get latest Amazon Linux/ECS optionmized AMI. block
      FunctionName: get-latest-amazon-ami
      MemorySize: 512
      Handler: index.handler
      Role:
        'Fn::GetAtt':
          - LambdaExecRole
          - Arn
      Timeout: 50
      Runtime: python3.6
      Code:
        ZipFile:
          'Fn::Sub': |
            import cfnresponse
            import time
            import boto3
            import re
            AMI_TYPE_MAPPING = {
              'AMAZON_LINUX': {
                  'owner': '137112412989',
                  'ami_name_pattern': 'amzn-ami-hvm-.*-gp2'
              },
              'ECS_OPTIMIZED':{
                  'owner': '591542846629',
                  'ami_name_pattern': 'amzn-ami-.*-ecs-optimized'
              }
            }
            def handler(event, context):
              if event['RequestType'] == 'Delete':
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={"Result":"Delete"})
                return
              try:
                ami_type = event['ResourceProperties']['AMIType']
                ec2_client = boto3.client('ec2')
                image = get_latest_AMI(ami_type,ec2_client)
                responseData = {"ImageId": image['ImageId'], "Name":image['Name']}
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData,image['ImageId'] )
              except Exception as e:
                print("something went wrong \n: {0}".format(str(e)))
                cfnresponse.send(event, context, cfnresponse.FAILED)

            def get_latest_AMI(ami_type, ec2_client):
              response = ec2_client.describe_images(
                  Filters = [
                      {
                          'Name': 'is-public',
                          'Values': ['true']
                      },
                      {
                          'Name': 'owner-alias',
                          'Values': ['amazon']
                      },
                      {
                          'Name': 'virtualization-type',
                          'Values': ['hvm']
                      },
                      {
                          'Name': 'image-type',
                          'Values': ['machine']
                      },
                      {
                          'Name': 'root-device-type',
                          'Values': ['ebs']
                      },
                      {
                          'Name': 'owner-id',
                          'Values': [AMI_TYPE_MAPPING[ami_type]['owner']]
                      },
                      {
                          'Name': 'block-device-mapping.volume-type',
                          'Values': ['gp2']
                      },
                      {
                          'Name': 'architecture',
                          'Values': ['x86_64']
                      }
                  ],
                  Owners=['amazon']
              )
              images = response['Images']
              amazon_hvm = []
              prog = re.compile(AMI_TYPE_MAPPING[ami_type]['ami_name_pattern'])
              creation_time_pattern = '%Y-%m-%dT%H:%M:%S.000Z'
              for image in images:
                  if prog.match(image['Name']):
                      if '.rc' not in image['Name']:
                          amazon_hvm.append(image)
              latest_image = max(amazon_hvm, key=lambda p: int(time.mktime(time.strptime(p['CreationDate'], creation_time_pattern))))
              print(latest_image['ImageId'])
              return latest_image
  ECSOptimizedAMI:
    Type: 'Custom::GetLatestAMI'
    Properties:
      ServiceToken:
        !GetAtt GetLatestAMILambda.Arn
      AMIType: ECS_OPTIMIZED
      DummyProp: 0

  EcsSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: ECS Allowed Ports
      VpcId:
        Fn::ImportValue: !Sub ${StackPrefix}-VpcId
      SecurityGroupIngress:
        - IpProtocol: -1
          FromPort: !Ref EcsPort
          ToPort: !Ref EcsPort
          CidrIp:  !Ref SourceCidr
        - IpProtocol: -1
          FromPort: '1'
          ToPort: '65535'
          SourceSecurityGroupId: !Ref ALBSecurityGroup
        - IpProtocol: -1
          FromPort: !Ref EcsPort
          ToPort: !Ref EcsPort
          CidrIp: !Ref SourceCidr
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub "${StackPrefix}-cluster"

  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      SecurityGroupIngress:
        - ToPort: 80
          IpProtocol: tcp
          CidrIp: 0.0.0.0/0
          FromPort: 80
      VpcId:
        Fn::ImportValue: !Sub ${StackPrefix}-VpcId
      GroupDescription: Service ALB SG
  EcsInstanceAsg:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
      - Fn::Join:
        - ","
        - - Fn::ImportValue:
              !Sub ${StackPrefix}-Public-Subnet-0
          - Fn::ImportValue:
              !Sub ${StackPrefix}-Public-Subnet-1
      LaunchConfigurationName:
        Ref: EcsInstanceLc
      MinSize:
        Ref: AsgMinSize
      MaxSize:
        Ref: AsgMaxSize
      DesiredCapacity:
        Ref: AsgMaxSize
      Tags:
      - Key: Name
        Value:
          Fn::Join:
          - ''
          - - 'ECS Instance - '
            - Ref: AWS::StackName
        PropagateAtLaunch: 'true'

  ECSLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${StackPrefix}-alb
      Subnets:
        -
          Fn::ImportValue:
            !Sub ${StackPrefix}-Public-Subnet-0
        -
          Fn::ImportValue:
            !Sub ${StackPrefix}-Public-Subnet-1
      SecurityGroups:
        - !Ref ALBSecurityGroup
      Scheme: internet-facing
  LoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ECSLoadBalancer
      Port: !Ref ElbPort
      Protocol: HTTP
      DefaultActions:
      - Type: forward
        TargetGroupArn: !Ref DefaultTargetGroup

  EcsInstanceLc:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      ImageId:
        Ref: ECSOptimizedAMI
      InstanceType:
        Ref: EcsInstanceType
      AssociatePublicIpAddress: true
      IamInstanceProfile:
        Ref: IamRoleInstanceProfile
      KeyName:
        Fn::If:
        - CreateEC2LCWithKeyPair
        - Ref: KeyName
        - Ref: AWS::NoValue
      SecurityGroups:
      - Ref: EcsSecurityGroup
      UserData:
        Fn::Base64:
          !Sub |
            #!/bin/bash
            echo ECS_CLUSTER=${ECSCluster} >> /etc/ecs/ecs.config
            #echo ECS_BACKEND_HOST=${EcsEndpoint} >> /etc/ecs/ecs.config
  DefaultTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${StackPrefix}-target-group"
      VpcId:
        Fn::ImportValue: !Sub ${StackPrefix}-VpcId
      Port: !Ref ElbPort
      Protocol: HTTP

Outputs:
  ECSCluster:
    Value: !Ref ECSCluster
    Export:
      Name: !Sub ${StackPrefix}-cluster-name
  EcsTargetGroup:
    Value: !Ref DefaultTargetGroup
    Export:
      Name: !Sub ${StackPrefix}-default-tg
  EcsInstanceLc:
    Value: !Ref EcsInstanceLc
    Export:
      Name: !Sub ${StackPrefix}-instance-lc
  LoadBalancerListener:
    Value:  !Ref LoadBalancerListener
    Export:
      Name: !Sub ${StackPrefix}-lb-listener
  LoadBalancerDNS:
    Value:  !Sub ${ECSLoadBalancer.DNSName}
    Export:
      Name: !Sub ${StackPrefix}-lb-dns
